<!-- GFM-TOC -->
* [算法思想](#算法思想)
    * [双指针](#双指针)
    * [排序](#排序)
        * [快速选择](#快速选择)
        * [桶排序](#桶排序)
        * [荷兰国旗问题](#荷兰国旗问题)
    * [二分查找](#二分查找)
    * [搜索](#搜索)
	    * [BFS](#bfs)
        * [DFS](#dfs)
        * [Backtracking](#backtracking)
    * [动态规划](#动态规划)
        * [斐波那契数列](#斐波那契数列)
        * [矩阵路径](#矩阵路径)
        * [数组区间](#数组区间)
        * [分割整数](#分割整数)
        * [最长递增子序列](#最长递增子序列)
        * [最长公共子序列](#最长公共子序列)
        * [0-1 背包](#0-1-背包)
        * [股票交易](#股票交易)
        * [字符串编辑](#字符串编辑)
    * [数学](#数学)
        * [素数](#素数)
        * [最大公约数](#最大公约数)
        * [进制转换](#进制转换)
        * [阶乘](#阶乘)
        * [字符串加法减法](#字符串加法减法)
        * [相遇问题](#相遇问题)
        * [多数投票问题](#多数投票问题)
        * [其它](#其它)
* [数据结构相关](#数据结构相关)
    * [树](#树)
        * [递归](#递归)
        * [层次遍历](#层次遍历)
        * [前中后序遍历](#前中后序遍历)
        * [BST](#bst)
        * [Trie](#trie)
    * [栈和队列](#栈和队列)
    * [哈希表](#哈希表)
    * [字符串](#字符串)
    * [数组与矩阵](#数组与矩阵)
    * [链表](#链表)
    * [图](#图)
        * [二分图](#二分图)
        * [拓扑排序](#拓扑排序)
        * [并查集](#并查集)
    * [位运算](#位运算)
* [参考资料](#参考资料)
<!-- GFM-TOC -->

# 算法思想

## 双指针

双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。

**有序数组的 Two Sum** 

[Leetcode ：167. Two Sum II - Input array is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

```html
Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
```

题目描述：在有序数组中找出两个数，使它们的和为 target。

使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) {
            return new int[]{i + 1, j + 1};
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    return null;
}
```

## 排序
### 快速排序
**topK**
[Leetcode ：215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)
1.快排或堆排后，取第K个。O(NlogN）
2.冒泡排序，排到第K个。O(N*K)
3.堆排序，维护一个K小顶堆。适用于数据量很大的情况下，只需要开辟K个空间。O(NlogK)
4.快排。时间复杂度较低，inplace，不适用数据量很大的时候。O(N)，最差O(N*N)。采用随机选择降低复杂度。

快排：
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        if(k<=0 || k>nums.length)
            return -1;
        int lo = 0;
        int hi = nums.length - 1;
        k = nums.length - k ;
        while(lo < hi){
            int j = partition(nums, lo, hi);
            if(j < k) {
                lo = j + 1;
            } else if (j > k) {
                hi = j - 1;
            } else {
                break;
            }
        }      
        return nums[k];
    }
    public int partition(int[] array, int start, int end){
        int pivot = (int)(start + Math.random()*(end - start + 1));
        int small = start - 1;
        swap(array, pivot, end);
        for(int i=start; i<=end; ++i){
            if(array[i] <= array[end]){
                small++;
                if(i > small)
                    swap(array, i, small);
            }
        }
        return small;
    }  
    public void swap(int[] array, int i, int j){
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }  
}
```

堆排：
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int val : nums) {
            pq.offer();
            if(pq.size() > k) {
                pq.poll();
            }
        }
        return pq.peek();  
    }
}
```

### 桶排序
**出现频率最多的 k 个数** 

[347. Top K Frequent Elements (Medium)](https://leetcode.com/problems/top-k-frequent-elements/description/)

```html
Given [1,1,1,2,2,3] and k = 2, return [1,2].
```

设置若干个桶，每个桶存储出现频率相同的数，并且桶的下标代表桶中数出现的频率，即第 i 个桶中存储的数出现的频率为 i。

把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。

```java
public List<Integer> topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> frequencyForNum = new HashMap<>();
    for (int num : nums) {
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    }
    List<Integer>[] buckets = new ArrayList[nums.length + 1];
    for (int key : frequencyForNum.keySet()) {
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) {
            buckets[frequency] = new ArrayList<>();
        }
        buckets[frequency].add(key);
    }
    List<Integer> topK = new ArrayList<>();
    for (int i = buckets.length - 1; i >= 0 && topK.size() < k; i--) {
        if (buckets[i] != null) {
            topK.addAll(buckets[i]);
        }
    }
    return topK;
}
```

**按照字符出现次数对字符串排序** 

[451. Sort Characters By Frequency (Medium)](https://leetcode.com/problems/sort-characters-by-frequency/description/)

```html
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

```java
public String frequencySort(String s) {
    Map<Character, Integer> frequencyForNum = new HashMap<>();
    for (char c : s.toCharArray())
        frequencyForNum.put(c, frequencyForNum.getOrDefault(c, 0) + 1);

    List<Character>[] frequencyBucket = new ArrayList[s.length() + 1];
    for (char c : frequencyForNum.keySet()) {
        int f = frequencyForNum.get(c);
        if (frequencyBucket[f] == null) {
            frequencyBucket[f] = new ArrayList<>();
        }
        frequencyBucket[f].add(c);
    }
    StringBuilder str = new StringBuilder();
    for (int i = frequencyBucket.length - 1; i >= 0; i--) {
        if (frequencyBucket[i] == null) {
            continue;
        }
        for (char c : frequencyBucket[i]) {
            for (int j = 0; j < i; j++) {
                str.append(c);
            }
        }
    }
    return str.toString();
}
```
### 荷兰国旗问题

荷兰国旗包含三种颜色：红、白、蓝。

有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。

它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。

<div align="center"> <img src="pics/3b49dd67-2c40-4b81-8ad2-7bbb1fe2fcbd.png"/> </div><br>

**按颜色进行排序** 

[75. Sort Colors (Medium)](https://leetcode.com/problems/sort-colors/description/)

```html
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

题目描述：只有 0/1/2 三种颜色。

```java
public class Solution {
    public void sortColors(int[] nums) {
        int j = 0, k = nums.length - 1;
        for(int i = 0; i <= k; ++i){
            if(nums[i] == 0)
                swap(nums, i, j++);
            else if(nums[i] == 2){
                swap(nums, i--, k--);
            }
        }
    }
    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

## 二分查找
[二分总结](http://www.cnblogs.com/grandyang/p/6854825.html)
[旋转总结](https://blog.csdn.net/smallplum123/article/details/77867086)
**旋转有序数组寻找数**
```html
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```
```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left)/2;
            if(target == nums[mid]) return mid;
            if(nums[mid] > nums[right]){
                if(target < nums[mid] && target >= nums[left])
                    right = mid - 1;
                else
                    left = mid + 1;
            } 
            else{
                if(target > nums[mid] && target <= nums[right])
                    left = mid + 1;
                else
                    right = mid - 1;
            }

        }
        return -1;
    }
}
```

**寻找数的范围**
[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
```html
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {        
        int[] res = new int[]{-1, -1};        
        int left = 0, right = nums.length -1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(target > nums[mid]) left = mid + 1;
            else right = mid;
        }
        if(nums.length == 0 || nums[right] != target) return res;
        res[0] = right;
        right = nums.length;
        while(left < right){
            int mid = left + (right - left)/2;
            if(target >= nums[mid]) left = mid + 1;
            else right = mid;
        }   
        res[1] = left - 1;
        return res;
    }
}
/*
class Solution {
    public int[] searchRange(int[] nums, int target) {        
        int left = BS(nums, target - 0.5);
        int right = BS(nums, target + 0.5);
        if(right - left <= 0) 
            return new int[]{-1, -1};
        else
            return new int[]{left, right - 1};
    }
    private int BS(int[] nums, double target){
        int left = 0, right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left)/2;
            if(target > nums[mid])
                left = mid + 1;
            else 
                right = mid - 1;
        }
        return left;
    }
}
*/
```
**求数的幂**
[50. Pow(x, n)](https://leetcode.com/problems/powx-n/)
```html
Input: 2.00000, 10
Output: 1024.00000

Note:
-100.0 < x < 100.0
n is a 32-bit signed integer, within the range [−231, 231 − 1]
```

```java
class Solution {
    public double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2){
            if((i & 1) == 1)
                res *= x;
            x *= x;
        }
        return n >= 0?res:1/res;
    }
}
/*使用绝对值会有整型溢出
class Solution {
    public double myPow(double x, int n) {
        int e = Math.abs(n);
        double res = 1.0;
        while(e != 0){
            if((e&1) == 1)
                res *= x;
            x *= x;
            e >>= 1;
        }
        return n >= 0?res:1/res;
    }
}
*/
```

## 搜索

### BFS

<div align="center"> <img src="pics/4ff355cf-9a7f-4468-af43-e5b02038facc.jpg"/> </div><br>

广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。

第一层：

- 0 -> {6,2,1,5}

第二层：

- 6 -> {4}
- 2 -> {}
- 1 -> {}
- 5 -> {3}

第三层：

- 4 -> {}
- 3 -> {}

每一层遍历的节点都与根节点距离相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub> <= d<sub>j</sub>。利用这个结论，可以求解最短路径等  **最优解**  问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径。

在程序实现 BFS 时需要考虑以下问题：

- 队列：用来存储每一轮遍历得到的节点；
- 标记：对于遍历过的节点，应该将它标记，防止重复遍历。

**计算在网格中从原点到特定点的最短路径长度** 

```html
[[1,1,0,1],
 [1,0,1,0],
 [1,1,1,1],
 [1,0,1,1]]
```

1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。

```java
public int minPathLength(int[][] grids, int tr, int tc) {
    final int[][] direction = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    final int m = grids.length, n = grids[0].length;
    Queue<Pair<Integer, Integer>> queue = new LinkedList<>();
    queue.add(new Pair<>(0, 0));
    int pathLength = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        pathLength++;
        while (size-- > 0) {
            Pair<Integer, Integer> cur = queue.poll();
            int cr = cur.getKey(), cc = cur.getValue();
            grids[cr][cc] = 0; // 标记
            for (int[] d : direction) {
                int nr = cr + d[0], nc = cc + d[1];
                if (nr < 0 || nr >= m || nc < 0 || nc >= n || grids[nr][nc] == 0) {
                    continue;
                }
                if (nr == tr && nc == tc) {
                    return pathLength;
                }
                queue.add(new Pair<>(nr, nc));
            }
        }
    }
    return -1;
}
```

**组成整数的最小平方数数量** 

[279. Perfect Squares (Medium)](https://leetcode.com/problems/perfect-squares/description/)

```html
For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.
```

可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。

要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。

本题也可以用动态规划求解，在之后动态规划部分中会再次出现。

```java
class Solution {
    public int numSquares(int n) {
        List<Integer> squares = generateSquares(n);
        Queue<Integer> que = new LinkedList<>();
        boolean[] marked = new boolean[n + 1];
        que.offer(n);
        int level = 0;
        while(!que.isEmpty()){
            int size = que.size();            
            level++;
            while(size-- != 0){
                int cur = que.poll();
                for(int num : squares){                
                    int next = cur - num;
                    if(next < 0)
                        break;
                    if(next == 0)
                        return level;
                    if(marked[next])
                        continue;
                    marked[next] = true;
                    que.add(next);
                }
            }
        }
        return n;
    }
    private List<Integer> generateSquares(int n){
        int base = 1;
        List<Integer> squares = new ArrayList<>();
        int square = 1;
        while(square <= n){
            square = base * base;
            squares.add(square);
            base++;
        }
        return squares;
    }
}

/*DP
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for(int i = 1; i <= n; ++i){
            int min = Integer.MAX_VALUE;
            int j = 1;
            while(i - j * j >= 0){
                min = Math.min(min, dp[i - j * j] + 1);
                j++;
            }
            dp[i] = min;
        }
        return dp[n];
    }
}
*/
```


### DFS

[337. House Robber III (Medium)](https://leetcode.com/problems/house-robber-iii/)

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = robSub(root);
        return Math.max(res[0], res[1]);
    }

    private int[] robSub(TreeNode root) {
        if (root == null) return new int[2];
    
        int[] left = robSub(root.left);
        int[] right = robSub(root.right);
        int[] res = new int[2];

        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);//第0位表示root不抢的情况
        res[1] = root.val + left[0] + right[0];//第1位表示root抢的情况
    
        return res;
    }
}
下面两种效率低下，重复计算
/*
class Solution {
    public int rob(TreeNode root) {
        if(root == null) return 0;
        int val = 0;
        if(root.left != null)
            val += rob(root.left.left) + rob(root.left.right);
        if(root.right != null)
            val += rob(root.right.left) + rob(root.right.right);
        return Math.max(val + root.val, rob(root.left) + rob(root.right));
    }
}
*/
/*dfs
class Solution {
    public int rob(TreeNode root) {
        return helper(root, 0, false);
    }
    
    private int helper(TreeNode root, int sum, boolean preflag){
        if( root == null)
            return 0;
        if(preflag)
            sum += helper(root.left, sum, !preflag) + helper(root.right, sum, !preflag);
        else
            sum += Math.max(helper(root.left, sum, preflag) + helper(root.right, sum, preflag),
                            helper(root.left, sum, !preflag) + helper(root.right, sum, !preflag) + root.val); 
        return sum;
    }
}
*/
```
### backtracking
[通用解法](https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)
#### 全排列问题

**全排列数组（无重复）**
[Leetcode ：46. Permutations](https://leetcode.com/problems/permutations/)
```html
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        // Arrays.sort(nums); // not necessary
        backtracking(res, new ArrayList<Integer>(), nums);
        return res;
    }
    private void backtracking(List<List<Integer>> res, List<Integer> list, int[] nums){
        if(list.size() == nums.length){
            res.add(new ArrayList<>(list));
        }
        else
            for(int i = 0; i < nums.length; ++i){
                if(list.contains(nums[i])) continue;
                list.add(nums[i]);
                backtracking(res, list, nums);
                list.remove(list.size() - 1);
        }
    }
}
```

**全排列数组（有重复）**
[Leetcode ：47. Permutations II](https://leetcode.com/problems/permutations-ii/)
```html
Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```
思路：在访问过的位置做标记。The worst-case time complexity is O(n! * n).
```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        backtracking(res, new ArrayList<Integer>(), nums, new boolean[nums.length]);
        return res;
    }
    private void backtracking(List<List<Integer>> res, List<Integer> list, int[] nums, boolean[] used){
        if(list.size() == nums.length)
            res.add(new ArrayList<>(list));
        else
            for(int i = 0; i < nums.length; ++i){
                if(used[i] || i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;//前面的位置也是未访问过的
                used[i] = true;
                list.add(nums[i]);
                backtracking(res, list, nums, used);
                used[i] = false;
                list.remove(list.size() - 1);
            }
    }
}
```

**下一个排列**
[Leetcode ：31. Next Permutation](https://leetcode.com/problems/next-permutation/)
```html
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```
思路：1.从后往前找到第一个比后面小的数。2.从后往前找第一个比之前找到的数大，调换两个数。3.将调换后后面所有数翻转。  
字符串排列也可以用这个思路。
```java
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length <=1) return;
        int i = nums.length - 2;
        while(i >=0 && nums[i] >= nums[i+1]) i--;
        if(i >= 0){
            int j = nums.length - 1;
            while(nums[i] >= nums[j]) j--;
            swap(nums, i, j);
        }
        reverse(nums, i + 1, nums.length - 1);
    }
    
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    private void reverse(int[] nums, int i, int j){
        while(i < j) swap(nums, i++, j--);
    }
}
```
#### 其他

**找出所有和为sum的子数组（可以重复）**
[Leetcode ：39. Combination Sum](https://leetcode.com/problems/combination-sum/)
```html
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
```
```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(candidates);
        backtrack(list, new ArrayList<>(), candidates, target, 0);
        return list;
        
    }
    
    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int target, int start){
        if(target < 0) return;
        else if(target == 0) list.add(new ArrayList<>(tempList));
        else{
            for(int i = start; i < nums.length; ++i){
                tempList.add(nums[i]);
                backtrack(list, tempList, nums, target - nums[i], i);// not i + 1 because we can reuse same elements
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}
```

**找出所有和为sum的子数组（可以重复）**
[Leetcode ：40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)
```html
Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```
```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(candidates);
        backtrack(list, new ArrayList<>(), candidates, target, 0);
        return list;
        
    }
    
    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int target, int start){
        if(target < 0) return;
        else if(target == 0) list.add(new ArrayList<>(tempList));
        else{
            for(int i = start; i < nums.length; ++i){
                if(i > start && nums[i] == nums[i - 1]) continue;
                tempList.add(nums[i]);
                backtrack(list, tempList, nums, target - nums[i], i + 1);// not i + 1 because we can reuse same elements
                tempList.remove(tempList.size() - 1);
            }
        }
    }
}
```

**子集（无重复数字）**
[Leetcode ：78. Subsets](https://leetcode.com/problems/subsets/)
```html
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        back(list, new ArrayList<Integer>(), nums, 0);
        return list;
    }
    private void back(List<List<Integer>> list, List<Integer> temp, int[] nums, int start){
        list.add(new ArrayList<>(temp));
        for(int i = start; i < nums.length; ++i){
            temp.add(nums[i]);
            back(list, temp, nums, i + 1);
            temp.remove(temp.size() - 1);
        }
    }
}
```
**子集（有重复数字）**
[Leetcode ：90. Subsets II](https://leetcode.com/problems/subsets-ii/)
```html
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```
```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        backtracking(res, new ArrayList<Integer>(), nums, 0);
        return res;
    }    
    private void backtracking(List<List<Integer>> res, List<Integer> list, int[] nums, int start){
        res.add(new ArrayList<>(list));
        for(int i = start; i < nums.length; ++i){
            if(i > start && nums[i] == nums[i - 1]) continue;
            list.add(nums[i]);
            backtracking(res, list, nums, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```


## 动态规划

递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。在找状态转移方程时，先确定好条件，然后分析能不能找到问题全集。

### 斐波那契数列

**爬楼梯**

[70. Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-2]"/></div> <br>

```java
class Solution {
    public int climbStairs(int n) {
        if (n==1) return 1;
        if (n==2) return 2;
        int[] dp=new int[n+1];
        dp[1]=1;
        dp[2]=2;
        for(int i=3;i<=n;++i){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

```java
public int climbStairs(int n) {
    if (n <= 2) {
        return n;
    }
    int pre2 = 1, pre1 = 2;
    for (int i = 2; i < n; i++) {
        int cur = pre1 + pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}
```
**强盗抢劫** 

[198. House Robber (Easy)](https://leetcode.com/problems/house-robber/description/)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。

由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以

<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2]+nums[i],dp[i-1])"/></div> <br>

```java
//优化空间
class Solution {
    public int rob(int[] nums) {
        int pre2 = 0, pre1 = 0;
        for (int i = 0; i < nums.length; i++) {
            int cur = Math.max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
}
/*rob(i) = Math.max( rob(i - 2) + currentHouseValue, rob(i - 1) )
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;dp[1] = nums[0];
        for(int i = 2; i <= nums.length; ++i){
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
        }
        return dp[nums.length];
    }
}
*/
```

**强盗在环形街区抢劫** 

[213. House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/description/)

第一行代表第一家抢了，第二行代表第一家没被抢。
```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length < 1) return 0;
        if(nums.length == 1) return nums[0];
        int[][] dp = new int[2][nums.length + 1];
        dp[0][0] = 0; dp[0][1] = 0;
        dp[1][0] = 0; dp[1][1] = nums[0];
        for(int i = 1; i < nums.length; ++i){
            dp[0][i + 1] = Math.max(dp[0][i], dp[0][i - 1] + nums[i]);
            dp[1][i + 1] = Math.max(dp[1][i], dp[1][i - 1] + nums[i]);
        }
        return Math.max(dp[0][nums.length], dp[1][nums.length - 1]);
    }
}
```
优化空间
```java
public int rob(int[] nums) {
    if (nums.length == 1) return nums[0];
    return Math.max(rob(nums, 0, nums.length - 2), rob(nums, 1, nums.length - 1));
}
private int rob(int[] num, int lo, int hi) {
    int include = 0, exclude = 0;
    for (int j = lo; j <= hi; j++) {
        int i = include, e = exclude;
        include = e + num[j];
        exclude = Math.max(e, i);
    }
    return Math.max(include, exclude);
}

//
class Solution {
    public int rob(int[] nums) {
        int n=nums.length,max=0;
        if(n==0) return 0;
        if(n==1) return nums[0];
        if(n==2) return Math.max(nums[0],nums[1]);
        int[] res=new int[n];
        for(int k=0;k<2;k++){
            res[0]=0;res[1]=nums[k];
            for(int i=1;i<n-1;i++){
                res[i+1]=Math.max(res[i],res[i-1]+nums[(i+k)%n]);
            }
            max=Math.max(max,res[n-1]);
        }
        return max;
    }
}
```

**信件错排** 

题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。

也就是经典的装错信封问题
 用A、B、C……表示写着ｎ位友人名字的信封，a、b、c……表示ｎ份相应的写好的信纸。把错装的总数为记作D(n)。假设把ａ错装进Ｂ里了，包含着这个错误的一切错装法分两类：
(1)b装入Ａ里，这时每种错装的其余部分都与A、B、a、b无关，应有D(n－2)种错装法。
(2)ｂ装入A、B之外的一个信封，这时的装信工作实际是把（除a之外的）n－1份信纸ｂ、ｃ……装入（除B以外的）n－1个信封A、C……，显然这时装错的方法有D(n－1)种。
总之在ａ装入B的错误之下，共有错装法D(n－2)＋D(n－1)种。
a装入C，装入D……的n－2种错误之下，同样都有D(n－1)＋D(n－2)种错装法，因此D(n)＝(n－1)[D(n－1)＋D(n－2)]

综上所述，错误装信数量方式数量为：
<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=(i-1)*dp[i-2]+(i-1)*dp[i-1]"/></div> <br>

```java
private static int solution(int n) {
    int[] dp = new int[n+1];
    dp [2] = 1;
    for (int i = 3; i<=n;i++) {
        dp [i] = (i-1)*( dp [i-1]+ dp [i-2]);
    }
    return dp [n];
}
```
**母牛生产** 

[程序员代码面试指南-P181](#)

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-3]"/></div> <br>

**矩阵的最小路径和** 

[64. Minimum Path Sum (Medium)](https://leetcode.com/problems/minimum-path-sum/description/)

```html
[[1,3,1],
 [1,5,1],
 [4,2,1]]
Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.
```

题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length, col = grid[0].length;
        if(row <=0 || col <= 0) return 0;
        int[][] dp = new int[row][col];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < row; ++i)
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        for(int j = 1; j < col; ++j)
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        for(int i = 1; i < row; ++i){
            for(int j = 1; j < col; ++j){
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[row - 1][col - 1];
    }
}
//简洁版本
/*
public class Solution {
    public int minPathSum(int[][] grid) {
        int m=grid.length, n=grid[0].length;
        for(int i=1;i<n;i++) grid[0][i]+=grid[0][i-1];
        for(int i=1;i<m;i++) grid[i][0]+=grid[i-1][0];
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                    grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[m-1][n-1];
    }
}
*/
```

### 自然数分割
所谓整数划分，是指把一个正整数n写成如下形式：
n=m1+m2+m3+....+mi;（其中mi为正整数，并且1<=mi<=n），则{m1,m2,m3,....,mi}为n的一个划分。
如果{m1,m2,m3,....,mi}中的最大值不超过m，即max{m1,m2,m3,....,mi} <= m，则称它属于n的一个m划分。这里我们记n的m划分的个数为dp(n,m)；
例如当n=4时，它有5个划分：{4}、{3,1}、{2,2}、{2,1,1}、{1,1,1,1}；
注意：4=1+3和4=3+1被认为是同一个划分。
```java
public class Main {
	public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[][] dp = new int[1000][1000];
        dp[0][0] = 1;
        for(int i = 0; i <=n; ++i){
        	for(int j = 1; j <=n; ++j){
        		if(i >= j)
        			dp[i][j] = dp[i][j - 1] + dp[i - j][j];
        		else
        			dp[i][j] = dp[i][i];
        	}
        }
        System.out.println(dp[n][n]);
    }	
}
```
**M苹果放N盘子**
题目描述：把 M 个同样的苹果放在 N 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？ 
注意：5、1、1 和 1、5、1 是同一种分法，即顺序无关。

1. 递归出口：当只有一个盘子或者含有 0 个或1个苹果的时候只有一种方法 
2. 当盘子数 n 大于苹果数 m 时，则必有 n - m 个空盘子，所以只需求 m 个盘子放 m 个苹果时的方法数即可 
3. 当盘子数 n 小于等于 苹果数 m 时，总方法数 = 当含有一个空盘子时的方法数+不含空盘子时的方法数。

递归
```java
int fun(int m,int n)  //m个苹果放在n个盘子中共有几种方法
{
    if(m==0||n==1)  //因为我们总是让m>=n来求解的，所以m-n>=0,所以让m=0时候结束，如果改为m=1，
        return 1;    //则可能出现m-n=0的情况从而不能得到正确解    
    if(n>m)
        return fun(m,m);
    else
        return fun(m,n-1)+fun(m-n,n);

```
动态规划
```java
int main() {
	int apple, plate;
	cin >> apple >> plate;
	if (apple < 0 || apple > 10 || plate < 1 || plate > 10) {
		cout << -1 << endl;
		return -1;
	}
	vector<vector<int> > ivec(11, vector<int>(11, 0));
	for (int i = 0; i < 11; i++) {
		ivec[0][i] = 1;
		ivec[i][1] = 1;
	}
	for (int i = 1; i <= 10; ++i) {
		for (int j = 1; j <= 10; ++j) {
			if (j <= i)
				ivec[i][j] = ivec[i][j - 1] + ivec[i - j][j];
			else
				ivec[i][j] = ivec[i][i];
		}
	}
 
 
	cout << ivec[apple][plate] << endl;
	return 0;

```

### 卡塔兰数
```html
卡特兰数满足以下性质：     
令h(0)=1,h(1)=1，catalan数满足递推式。h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)。也就是说，如果能把公式化成上面这种形式的数，就是卡特兰数。      
当然，上面这样的递推公式太繁琐了，于是数学家们又求出了可以快速计算的通项公式。h(n)=c(2n,n)-c(2n,n+1)(n=0,1,2,...)。这个公式还可以更简单得化为h(n)=C(2n,n)/(n+1)=(2n!)/(n+1)!n!。后一个公式都可以通过前一个公式经过几步简单的演算得来，大家可以拿起笔试试，一两分钟就可以搞定。
1.子问题
2.子问题总数唯一
```
问题：
1.买票找零钱问题（一半人拿5元，一半人拿10元，票价如何排列可以顺利的售票）  
2.站队问题（站两排，每排必须从高到矮，二排必须比对应的一排人高）。  
3.一个足够大的栈的进栈序列为1,2,3,⋯,n时有多少个不同的出栈序列  
4.在n* n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？其实向右走相当于进栈，向左走相当于出栈，本质就是n个数出栈次序的问题，所以答案就是卡特兰数。  
5.将一个凸n+2边形区域分成三角形区域的方法数  

**BST的数量**
[Leetcode ：96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)
```html
题目描述：
Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /       / \       \
     3     2     1     1   3      2
    /     /       \                    \
   2     1         2                   3
```

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1; dp[1] = 1;
        for(int i = 2; i <= n; ++i){
            for(int j = 0; j < i; ++j){
                dp[i] += dp[j]*dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
```

**硬币找零**
[Leetcode ：322. Coin Change](https://leetcode.com/problems/coin-change/)
```html
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        for(int i = 1; i <= amount; ++i){
            dp[i] = i + 1;//不能用Integer.MAX_VALUE，如果后面加1会有溢出风险
            for(int j = 0; j < coins.length; ++j){
                if(i - coins[j] >= 0 && dp[i - coins[j]] != -1)
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
            if(dp[i] == i + 1)
                dp[i] = -1;
        }
        return dp[amount];
    }
}
```

**硬币找零2**
[Leetcode ：518. Coin Change 2](https://leetcode.com/problems/coin-change-2/)
```html
Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

```java
//dp优化空间
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }
}

//dp
class Solution {
    public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length+1][amount+1];
        dp[0][0] = 1;
        
        for (int i = 1; i <= coins.length; i++) {
            dp[i][0] = 1;
            for (int j = 1; j <= amount; j++) {
                dp[i][j] = dp[i-1][j] + (j >= coins[i-1] ? dp[i][j-coins[i-1]] : 0);
            }
        }
        return dp[coins.length][amount];
    }
}

/*回溯法超时
class Solution {
    int sum = 0;
    public int change(int amount, int[] coins) {
        Arrays.sort(coins);
        if(amount < 0) return 0;
        else if(amount == 0 && coins.length == 0) return 1;
        backtrack(coins, amount, 0);
        return sum;
    }
    
    private void backtrack(int[] nums, int target, int start){
        if(target < 0) return;
        else if(target == 0) sum++;
        else
            for(int i = start; i < nums.length; ++i){
                if(target - nums[i] < 0) break;
                backtrack(nums, target - nums[i], i);// not i + 1 because we can reuse same elements
            }
    }
}
*/
```
### 0-1 背包

有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。

定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：

- 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。
- 第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。

第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：

<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)"/></div> <br>

```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```
**空间优化** 

在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，

<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-w]+v)"/></div> <br>

因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，以防将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。

```java
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= 1; j--) {
            if (j >= w) {
                dp[j] = Math.max(dp[j], dp[j - w] + v);
            }
        }
    }
    return dp[W];
}
```
**Partition Equal Subset Sum**
[Leetcode ：416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
```html
Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
```
```java
//01背包
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums.length <= 1)
            return false;
        int sum = 0;
        for(int i:nums)
            sum += i;
        if(sum % 2 != 0)
            return false;
        boolean[][] dp = new boolean[nums.length + 1][sum/2 + 1];
        for(int i = 0; i <= nums.length; ++i)
            dp[i][0] = true;
        for(int i = 1; i <= nums.length; ++i){
            for(int j = sum/2; j >= nums[i - 1]; --j){
                dp[i][j] = dp[i- 1][j] || dp[i- 1][j - nums[i - 1]];
                if(dp[i][sum/2])
                    return true;
            }
        }
        return dp[nums.length][sum/2];
    }
}

/*
class Solution {
    public boolean canPartition(int[] nums) {
        if(nums.length <= 1)
            return false;
        int sum = 0;
        for(int i:nums)
            sum += i;
        if(sum % 2 != 0)
            return false;
        boolean[] dp = new boolean[sum/2 + 1];
        dp[0] = true;
        for(int i = 1; i <= nums.length; ++i){
            for(int j = sum/2; j >= nums[i - 1]; --j){
                dp[j] = dp[j] || dp[j - nums[i - 1]];
            }
        }
        return dp[sum/2];
    }
}
*/
```
**Target Sum**
[Leetcode ：494. Target Sum](https://leetcode.com/problems/target-sum/)
```html
Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
```
```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for(int num:nums)
            sum += num;
        if(sum < S || (sum + S)%2 == 1)
            return 0;
        int target = (sum + S)/2;
        int[][] dp = new int[nums.length + 1][target + 1];
        for(int i = 0; i <= nums.length; ++i)
            dp[i][0] = 1;
        for(int i = 1; i <= nums.length; ++i){
            for(int j = 0; j <= target; ++j){
                if(j >= nums[i - 1])
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
                else
                    dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[nums.length][target];
    }
}
/*空间优化
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = computeArraySum(nums);
        if (sum < S || (sum + S) % 2 == 1) {
            return 0;
        }
        int W = (sum + S) / 2;
        int[] dp = new int[W + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int i = W; i >= num; i--) {
                dp[i] = dp[i] + dp[i - num];
            }
        }
        return dp[W];
    }
}
*/
```
**字符串按单词列表分割** 

[139. Word Break (Medium)](https://leetcode.com/problems/word-break/description/)

```html
s = "leetcode",
dict = ["leet", "code"].
Return true because "leetcode" can be segmented as "leet code".
```

dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。

0-1 背包和完全背包在实现上的不同之处是，0-1 背包对物品的迭代是在最外层，而完全背包对物品的迭代是在最里层。

```java
public boolean wordBreak(String s, List<String> wordDict) {
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i <= n; i++) {
        for (String word : wordDict) {   // 完全一个物品可以使用多次
            int len = word.length();
            if (len <= i && word.equals(s.substring(i - len, i))) {
                dp[i] = dp[i] || dp[i - len];
            }
        }
    }
    return dp[n];
}
```
**找零钱的最少硬币数** 

[322. Coin Change (Medium)](https://leetcode.com/problems/coin-change/description/)

```html
Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.
```

题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。

- 物品：硬币
- 物品大小：面额
- 物品价值：数量

因为硬币可以重复使用，因此这是一个完全背包问题。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        dp[0] = 0;
        for(int i = 1; i <= amount; ++i){
            dp[i] = i + 1;//不能用Integer.MAX_VALUE，如果后面加1会有溢出风险
            for(int j = 0; j < coins.length; ++j){
                if(i - coins[j] >= 0 && dp[i - coins[j]] != -1)
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
            if(dp[i] == i + 1)
                dp[i] = -1;
        }
        return dp[amount];
    }
}
```
**组合总和** 

[377. Combination Sum IV (Medium)](https://leetcode.com/problems/combination-sum-iv/description/)

```html
nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
```

完全背包。

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for(int i = 0; i <= target; ++i){
            for(int j = 0; j < nums.length; ++j){
                if(i >= nums[j])
                    dp[i] = dp[i] + dp[i - nums[j]];
            }
        }
        return dp[target];
    }
}
```

## 数学

# 数据结构相关

## 树

**树的最大深度**
[Leetcode ：104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

采用深度优先搜索DFS算法，时间O(N), 空间O(H),递归栈空间

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1; 
    }
}
```

**树的最小深度**
[Leetcode ：111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

解法一：DFS算法，时间O(N), 空间O(H),递归栈空间

```java
class Solution {
    int min = 0;
    public int minDepth(TreeNode root) {
        if (root == null)	
			return 0;
	    if (root.left == null)	
			return minDepth(root.right) + 1;
	    if (root.right == null) 
			return minDepth(root.left) + 1;
	    return Math.min(minDepth(root.left),minDepth(root.right)) + 1;
    }
}
```

解法二：BFS算法，遇到第一个空节点就返回。类似层序遍历。时间 O(N) 空间 O(B)。  
类似解题：[Leetcode ：103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)
```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.offer(root);
        int depth = 0;
        while(!que.isEmpty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; ++i){
                TreeNode node = que.poll();
                if(node.left == null && node.right == null) return depth;
                if(node.left != null) que.offer(node.left);
                if(node.right != null) que.offer(node.right);
            }    
        }
        return depth;
    }
}
```
**最低公共祖先**
[Leetcode ：235,236.  Lowest Common Ancestor of a Binary Tree（LCA）](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

解法一：自顶向下，重复计算，效率低
```java
/*查找二叉树中两个结点最低公共祖先结点*/
struct node* LCA(struct node *root, struct node *p, struct node *q) 
{
    if (hasNode(root->left, p) && hasNode(root->left, q)) //p和q都在左子树中        
        return LCA(root->left, p, q);
    if (hasNode(root->right, p) && hasNode(root->right, q)) //p和q都在右子树中
        return LCA(root->right, p, q);
    return root; //p和q一个在左子树，一个在右子树中，直接返回root
}
 
/*判断root为根的树是否包含结点p*/
bool hasNode(struct node* root, struct node* p)
{
    if (!root) return false;
    if (root == p)
        return true;
    return hasNode(root->left, p) ||  hasNode(root->right, p);
}
```

解法二：自底向上遍历结点，一旦遇到结点等于p或者q，则将其向上传递给它的父结点。父结点会判断它的左右子树是否都包含其中一个结点，如果是，则父结点一定是这两个节点p和q的LCA，传递父结点到root。如果不是，我们向上传递其中的包含结点p或者q的子结点，或者NULL(如果子结点不包含任何一个)。该方法时间复杂度为O(N)。
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left != null && right != null) return root;
        else
            return left == null?right:left;
    }
}
```

## 字符串

**最长回文子串**
[Leetcode ：5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

参考[最长回文子串](https://www.cnblogs.com/grandyang/p/4464476.html)

解法一：遍历字符串，往两边查找。时间复杂度O(N*N).
```java
class Solution {
    public String longestPalindrome(String s) {
        String res="";
        int n=s.length();
        char[] ch=s.toCharArray();
        for(int i=0;i<n;i++){
            int j=i;
            while(j+1<n && ch[j]==ch[j+1]) j++;
            int cur=j;
            while(j+1<n && i-1>=0 && ch[j+1]==ch[i-1]){
                j++;i--;
            }
            if(j-i+1>res.length()){
                res=s.substring(i,j+1);
            }
            i=cur;
        }
        return res;
    } 
}

```

解法二：动态规划，DP[i][j]表示ij之间的最长回文串。时间复杂度O(N*N).
```java
public String longestPalindrome(String s) {
  int n = s.length();
  String res = null;
    
  boolean[][] dp = new boolean[n][n];
    
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i; j < n; j++) {
      dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);
            
      if (dp[i][j] && (res == null || j - i + 1 > res.length())) {
        res = s.substring(i, j + 1);
      }
    }
  }
    
  return res;
}
```

解法三：马拉车算法。时间复杂度O(N).  
参考[Manacher's Algorithm 马拉车算法](http://www.cnblogs.com/grandyang/p/4475985.html)
```java
class Solution {
    public String longestPalindrome(String s) {
        String t = "$#";
        for(int i = 0; i < s.length(); ++i){
            t += s.charAt(i);
            t += "#";
        }
        t += "@";
        int id = 0, mx = 0, resLen = 0, resCenter = 0;;
        int[] len = new int[t.length()];
        for(int i = 1; i < t.length() - 1; ++i){
            len[i] = (i < mx) ? Math.min(len[2*id - i], mx - i):1;
            while((i - len[i])>=0 && (i + len[i])< t.length() - 1 && t.charAt(i + len[i]) == t.charAt(i - len[i])) 
                len[i]++;
            if(i + len[i] > mx){·
                mx = i + len[i];
                id = i; 
            }
            if (resLen < len[i]) {
                resLen = len[i];
                resCenter = i;
            }
        }
        return s.substring((resCenter - resLen) / 2, (resCenter - resLen) / 2 + resLen-1);
    }    
}
```
**最长回文子序列**
[Leetcode ：516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)  
参考[最长回文子序列](https://www.cnblogs.com/grandyang/p/6493182.html)

解法一：动态规划
```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];
        int max = 0;
        for(int i = s.length() - 1; i >=0; --i){
            dp[i][i] = 1;
            for(int j = i + 1; j < s.length(); ++j){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        return dp[0][s.length() - 1];
    }
}
```
解法二：优化空间
解法三：缓存计算过的结果

**最长公共子串**
描述：给定两个字符串，求出它们之间最长的相同子字符串的长度。  
参考：[最长公共子序列与最长公共子串](https://www.cnblogs.com/en-heng/p/3963803.html)  
字母连续：二维数组c[i,j]c[i,j]用来记录具有这样特点的子串——结尾为母串x1x2⋯xi与y1y2⋯yj的结尾——的长度
```java
public static int lcs(String str1, String str2) {
    int len1 = str1.length();
    int len2 = str2.length();
    int result = 0;     //记录最长公共子串长度
    int c[][] = new int[len1+1][len2+1];
    for (int i = 0; i <= len1; i++) {
        for( int j = 0; j <= len2; j++) {
            if(i == 0 || j == 0) {
                c[i][j] = 0;
            } else if (str1.charAt(i-1) == str2.charAt(j-1)) {
                c[i][j] = c[i-1][j-1] + 1;
                result = Math.max(c[i][j], result);
            } else {
                c[i][j] = 0;
            }
        }
    }
    return result;
}
```

字母可以不连续：二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度
```java
public static int lcs(String str1, String str2) {
    int len1 = str1.length();
    int len2 = str2.length();
    int c[][] = new int[len1+1][len2+1];
    for (int i = 0; i <= len1; i++) {
        for( int j = 0; j <= len2; j++) {
            if(i == 0 || j == 0) {
                c[i][j] = 0;
            } else if (str1.charAt(i-1) == str2.charAt(j-1)) {
                c[i][j] = c[i-1][j-1] + 1;
            } else {
                c[i][j] = max(c[i - 1][j], c[i][j - 1]);
            }
        }
    }
    return c[len1][len2];
}
```
**最长公共子序列(数组）**
[Leetcode ：718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)  
解法一：动态规划，时间O(M*N),空间O(M*N)

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int len1 = A.length;
        int len2 = B.length;
        int[][] dp = new int[len1 + 1][len2 + 1];
        int max = 0;
        for(int i = 0; i <= len1; ++i){
            for(int j = 0; j <= len2; ++j){
                if(i == 0 || j == 0) dp[i][j] = 0;
                else if(A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
//                else
//                  dp[i][j] = 0;
                max = Math.max(max, dp[i][j]);
            }
        }
        return max;
    }
}
```
解法二：优化空间,空间复杂度是O(max(m,n))
```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int len1 = A.length;
        int len2 = B.length;
        int[] dp = new int[len2 + 1];
        int max = 0;
        for(int i = 1; i <= len1; ++i){
            for(int j = len2; j > 0; --j){
                if(A[i - 1] == B[j - 1]){
                    dp[j] = dp[j - 1] + 1;
                    max = Math.max(max, dp[j]);    
                }
                else
                    dp[j] = 0;
            }
        }
        return max;            
    }
}
```

**回文串分割1**
[Leetcode ：131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)  
```html
Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
```
DFS:
```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        List<String> list = new ArrayList<>();
        helper(s, 0, res, list);
        return res;
    }
    
    private void helper(String s, int start, List<List<String>> res, List<String> list){
        if(start == s.length()){
            res.add(new ArrayList<String>(list));
            return;
        }
        for(int i = start; i < s.length(); ++i){
            if(isPalindrome(s.substring(start, i +1))){
                list.add(s.substring(start, i + 1));
                helper(s, i + 1, res, list);
                list.remove(list.size() - 1);
            }
        }
    }    
    private boolean isPalindrome(String s){
        int i = 0, j = s.length() - 1;
        while(i < j){
            if(s.charAt(i++) != s.charAt(j--))
                return false;
        }
        return true;
    }
}
```

**回文串分割2**
[Leetcode ：132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)  
```html
Input: "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
```
DP:
```java
class Solution {
    public int minCut(String s) {
        if(s.length() == 0) return 0;
        char[] sc = s.toCharArray();
        int[] dp = new int[sc.length];
        boolean[][] p = new boolean[sc.length][sc.length];
        for(int i = 0; i < sc.length; ++i){
            dp[i] = i;
            for(int j = 0; j <= i; ++j){
                if(sc[i] == sc[j] && (i - j < 2 || p[j + 1][i - 1])){
                    p[j][i] = true;
                    dp[i] = (j == 0) ? 0 : Math.min(dp[i], dp[j - 1] + 1);
                }
            }
        }
        return dp[sc.length - 1];
    }
}
```

## 数组

**多数数字**
BM（Boyer-Moore Majority Vote Algorithm）摩尔投票法：

***超过1/2的数***
[Leetcode ：169. Majority Element](https://leetcode.com/problems/majority-element/)

```html
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.不存在输出0.
Input: [2,2,1,1,1,2,2]
Output: 2
```

```java
//不能使用hashmap，O(1)的空间复杂度，O(n)的时间复杂度
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array.length == 0)
            return 0;
        int major=0,count=0;
        for(int i=0; i<array.length;i++){
            if(count==0){
                major=array[i];
                ++count;
            }
            else if(major==array[i]){
                ++count;
            }
            else
                --count;
        }
        int max=0;
        for(int i=0;i<array.length;++i){
            if(array[i]==major)
                ++max;
        }
        return max>array.length/2?major:0;
    }
}
```
***超过1/3的数***
[Leetcode ：229. Majority Element II](https://leetcode.com/problems/majority-element-ii/)

```java
//注意判断条件的顺序
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> list = new ArrayList<Integer>();
        int maj1 = 0, maj2 = 0, count1 = 0, count2 = 0;
        for(int a:nums){
            if(a == maj1)
                count1++;
            else if(a == maj2)
                count2++;
            else if(count1 == 0){
                count1++; 
                maj1 = a;
            }
            else if(count2 == 0){
                count2++;
                maj2 = a;
            }
            else{
                count1--;
                count2--;
            }
        }
        int max1 = 0, max2 = 0;
        for(int a:nums){
            if(a == maj1) max1++;
            else if(a == maj2) max2++;
        }
        if(max1 > nums.length/3)
            list.add(maj1);
        if(max2 > nums.length/3)
            list.add(maj2);
        return list;
    }
}
```

**递增序列**
***最长连续递增序列***
[Leetcode ：674. Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)
```html
Input: [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. 
Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. 
```

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int res = 0, cnt = 0;
        for(int i = 0; i < nums.length; i++){
            if(i == 0 || nums[i-1] < nums[i]) res = Math.max(res, ++cnt);
            else cnt = 1;
        }
        return res;
    }
}
```

***最长递增序列***
[Leetcode ：300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
```html
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```
解法一：动态规划O(N*N).dp[i]表示以nums[i]为结尾的最长递增子串的长度,dp[i] = max(dp[i], dp[j] + 1).
```java
//dp
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length + 1];
        dp[0] = 0;
        int max = 0;
        for(int i = 0; i < nums.length; ++i){
            dp[i + 1] = 1;
            for(int j = i; j >= 0; --j){
                if(nums[i] > nums[j])     
                    dp[i + 1] = Math.max(dp[i + 1], dp[j + 1] + 1);
            }
            max = Math.max(max, dp[i + 1]);
        }
        return max;
    }
}
```

解法二：等效覆盖法，O(N*logN)。
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length < 1) return 0;
        int[] ends = new int[nums.length];
        ends[0] = nums[0];
        int left = 0, right = 0, cnt = 1;
        for(int i = 1; i < nums.length; ++i){
            if(nums[i] < ends[0]) ends[0] = nums[i];
            else if(nums[i] > ends[right]) {
                ends[++right] = nums[i];
                cnt = right + 1;
            }
            else{
                while(left < right){
                    int mid = left + (right - left)/2;
                    if(nums[i] > ends[mid]) left = mid + 1;
                    else right = mid;
                }
                ends[right] = nums[i];
                left = 0;
                right = cnt - 1;
            }
        }
        return cnt;
    }
}
```
**2 sum**
[Leetcode ：1. Two Sum](https://leetcode.com/problems/two-sum/)
```html
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
    int[] result = new int[2];
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < numbers.length; i++) {
        if (map.containsKey(target - numbers[i])) {
            result[1] = i;
            result[0] = map.get(target - numbers[i]);
            return result;
        }
        map.put(numbers[i], i );
    }
    return result;
    }
}
```

**3 sum** **4 sum**
[Leetcode ：15. 3Sum](https://leetcode.com/problems/3sum/)
```html
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new LinkedList<>();
        Arrays.sort(nums);
        for (int i=0;i<nums.length-2;i++){
            if (i==0 || (i>0 && nums[i] != nums[i-1])){
                int lo = i+1, hi = nums.length-1, sum = 0 - nums[i];
                while (lo < hi){
                    if (nums[lo] + nums[hi] == sum){
                        res.add(Arrays.asList(nums[i],nums[lo],nums[hi]));
                        while(lo < hi && nums[lo] == nums[lo+1]) lo++;
                        while(lo < hi && nums[hi] == nums[hi-1]) hi--;
                        lo++;hi--;
                    }
                    else if (nums[lo] + nums[hi] < sum) lo++;
                    else hi--;
                }
            }
        }
        return res;
    }
}
```

## 链表

[Leetcode ：25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)
```html
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5
```
```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode cur = head;
        for(int i = 0; i < k; i++){
            if(cur == null)
                return head;
            else
                cur = cur.next;
        }
        ListNode newHead = reverse(head, cur);
        head.next = reverseKGroup(cur, k);
        return newHead;
    }
    
    private ListNode reverse(ListNode head, ListNode tail){
        ListNode pre = tail;
        while(head != tail){
            ListNode temp = head.next;
            head.next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }
}
```
[Leetcode ：24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)

```html
Given 1->2->3->4, you should return the list as 2->1->4->3.
```
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while(pre.next != null && pre.next.next != null){
            ListNode l1 = pre.next, l2 = pre.next.next, next = pre.next.next.next;
            l2.next = l1;
            l1.next = next;
            pre.next = l2;
            pre = l1;
        }
        return dummy.next;
    }
}
*/

public class Solution {
    public ListNode swapPairs(ListNode head) {
        if ((head == null)||(head.next == null))
            return head;
        ListNode n = head.next;
        head.next = swapPairs(head.next.next);
        n.next = head;
        return n;
    }
}
```

