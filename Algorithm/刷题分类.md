<!-- GFM-TOC -->
* [算法思想](#算法思想)
    * [双指针](#双指针)
    * [排序](#排序)
        * [快速选择](#快速选择)
        * [堆排序](#堆排序)
        * [桶排序](#桶排序)
        * [荷兰国旗问题](#荷兰国旗问题)
    * [贪心思想](#贪心思想)
    * [二分查找](#二分查找)
    * [分治](#分治)
    * [搜索](#搜索)
        * [BFS](#bfs)
        * [DFS](#dfs)
        * [Backtracking](#backtracking)
    * [动态规划](#动态规划)
        * [斐波那契数列](#斐波那契数列)
        * [矩阵路径](#矩阵路径)
        * [数组区间](#数组区间)
        * [分割整数](#分割整数)
        * [最长递增子序列](#最长递增子序列)
        * [最长公共子序列](#最长公共子序列)
        * [0-1 背包](#0-1-背包)
        * [股票交易](#股票交易)
        * [字符串编辑](#字符串编辑)
    * [数学](#数学)
        * [素数](#素数)
        * [最大公约数](#最大公约数)
        * [进制转换](#进制转换)
        * [阶乘](#阶乘)
        * [字符串加法减法](#字符串加法减法)
        * [相遇问题](#相遇问题)
        * [多数投票问题](#多数投票问题)
        * [其它](#其它)
* [数据结构相关](#数据结构相关)
    * [链表](#链表)
    * [树](#树)
        * [递归](#递归)
        * [层次遍历](#层次遍历)
        * [前中后序遍历](#前中后序遍历)
        * [BST](#bst)
        * [Trie](#trie)
    * [栈和队列](#栈和队列)
    * [哈希表](#哈希表)
    * [字符串](#字符串)
    * [数组与矩阵](#数组与矩阵)
    * [图](#图)
        * [二分图](#二分图)
        * [拓扑排序](#拓扑排序)
        * [并查集](#并查集)
    * [位运算](#位运算)
<!-- GFM-TOC -->


# 算法思想

## 双指针

双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。

**有序数组的 Two Sum** 

[Leetcode ：167. Two Sum II - Input array is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

```html
Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
```

题目描述：在有序数组中找出两个数，使它们的和为 target。

使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) {
            return new int[]{i + 1, j + 1};
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    return null;
}
```
## 动态规划

**有序数组的 Two Sum**

# 数据结构相关

## 树

**树的最大深度**
[Leetcode ：104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

采用深度优先搜索DFS算法，时间O(N), 空间O(H),递归栈空间

```java
public int[] twoSum(int[] numbers, int target) {
    int i = 0, j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) {
            return new int[]{i + 1, j + 1};
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    return null;
}
```

**树的最小深度**
[Leetcode ：111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

解法一：DFS算法，时间O(N), 空间O(H),递归栈空间

```java
class Solution {
    int min = 0;
    public int minDepth(TreeNode root) {
        if (root == null)	
			return 0;
	    if (root.left == null)	
			return minDepth(root.right) + 1;
	    if (root.right == null) 
			return minDepth(root.left) + 1;
	    return Math.min(minDepth(root.left),minDepth(root.right)) + 1;
    }
}
```

解法二：BFS算法，遇到第一个空节点就返回。类似层序遍历。时间 O(N) 空间 O(B)。
类似解题：[Leetcode ：103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)
```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> que = new LinkedList<>();
        que.offer(root);
        int depth = 0;
        while(!que.isEmpty()){
            int size = que.size();
            depth++;
            for(int i = 0; i < size; ++i){
                TreeNode node = que.poll();
                if(node.left == null && node.right == null) return depth;
                if(node.left != null) que.offer(node.left);
                if(node.right != null) que.offer(node.right);
            }    
        }
        return depth;
    }
}
```

## 字符串

**最长回文子串**
[Leetcode ：5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

参考[最长回文子串](https://www.cnblogs.com/grandyang/p/4464476.html)

解法一：遍历字符串，往两边查找。时间复杂度O(N*N).
```java
class Solution {
    public String longestPalindrome(String s) {
        String res="";
        int n=s.length();
        char[] ch=s.toCharArray();
        for(int i=0;i<n;i++){
            int j=i;
            while(j+1<n && ch[j]==ch[j+1]) j++;
            int cur=j;
            while(j+1<n && i-1>=0 && ch[j+1]==ch[i-1]){
                j++;i--;
            }
            if(j-i+1>res.length()){
                res=s.substring(i,j+1);
            }
            i=cur;
        }
        return res;
    } 
}

```

解法二：动态规划，DP[i][j]表示ij之间的最长回文串。时间复杂度O(N*N).
```java
public String longestPalindrome(String s) {
  int n = s.length();
  String res = null;
    
  boolean[][] dp = new boolean[n][n];
    
  for (int i = n - 1; i >= 0; i--) {
    for (int j = i; j < n; j++) {
      dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);
            
      if (dp[i][j] && (res == null || j - i + 1 > res.length())) {
        res = s.substring(i, j + 1);
      }
    }
  }
    
  return res;
}
```

解法三：马拉车算法。时间复杂度O(N).
参考[Manacher's Algorithm 马拉车算法](http://www.cnblogs.com/grandyang/p/4475985.html)
```java
class Solution {
    public String longestPalindrome(String s) {
        String t = "$#";
        for(int i = 0; i < s.length(); ++i){
            t += s.charAt(i);
            t += "#";
        }
        t += "@";
        int id = 0, mx = 0, resLen = 0, resCenter = 0;;
        int[] len = new int[t.length()];
        for(int i = 1; i < t.length() - 1; ++i){
            len[i] = (i < mx) ? Math.min(len[2*id - i], mx - i):1;
            while((i - len[i])>=0 && (i + len[i])< t.length() - 1 && t.charAt(i + len[i]) == t.charAt(i - len[i])) 
                len[i]++;
            if(i + len[i] > mx){
                mx = i + len[i];
                id = i; 
            }
            if (resLen < len[i]) {
                resLen = len[i];
                resCenter = i;
            }
        }
        return s.substring((resCenter - resLen) / 2, (resCenter - resLen) / 2 + resLen-1);
    }    
}
```
**最长回文子序列**
[Leetcode ：516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)
参考[最长回文子序列](https://www.cnblogs.com/grandyang/p/6493182.html)

解法一：动态规划
```
class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];
        int max = 0;
        for(int i = s.length() - 1; i >=0; --i){
            dp[i][i] = 1;
            for(int j = i + 1; j < s.length(); ++j){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        return dp[0][s.length() - 1];
    }
}
```
解法二：优化空间
解法三：缓存计算过的结果

**最长公共子串**
描述：给定两个字符串，求出它们之间最长的相同子字符串的长度。
参考：[最长公共子序列与最长公共子串](https://www.cnblogs.com/en-heng/p/3963803.html)
字母连续：二维数组c[i,j]c[i,j]用来记录具有这样特点的子串——结尾为母串x1x2⋯xi与y1y2⋯yj的结尾——的长度
```
public static int lcs(String str1, String str2) {
    int len1 = str1.length();
    int len2 = str2.length();
    int result = 0;     //记录最长公共子串长度
    int c[][] = new int[len1+1][len2+1];
    for (int i = 0; i <= len1; i++) {
        for( int j = 0; j <= len2; j++) {
            if(i == 0 || j == 0) {
                c[i][j] = 0;
            } else if (str1.charAt(i-1) == str2.charAt(j-1)) {
                c[i][j] = c[i-1][j-1] + 1;
                result = Math.max(c[i][j], result);
            } else {
                c[i][j] = 0;
            }
        }
    }
    return result;
}
```

字母可以不连续：二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度
```
public static int lcs(String str1, String str2) {
    int len1 = str1.length();
    int len2 = str2.length();
    int c[][] = new int[len1+1][len2+1];
    for (int i = 0; i <= len1; i++) {
        for( int j = 0; j <= len2; j++) {
            if(i == 0 || j == 0) {
                c[i][j] = 0;
            } else if (str1.charAt(i-1) == str2.charAt(j-1)) {
                c[i][j] = c[i-1][j-1] + 1;
            } else {
                c[i][j] = max(c[i - 1][j], c[i][j - 1]);
            }
        }
    }
    return c[len1][len2];
}
```
**最长公共子序列(数组）**
[Leetcode ：718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)
解法一：动态规划，时间O(M*N),空间O(M*N)

```
class Solution {
    public int findLength(int[] A, int[] B) {
        int len1 = A.length;
        int len2 = B.length;
        int[][] dp = new int[len1 + 1][len2 + 1];
        int max = 0;
        for(int i = 0; i <= len1; ++i){
            for(int j = 0; j <= len2; ++j){
                if(i == 0 || j == 0) dp[i][j] = 0;
                else if(A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
//                else
//                  dp[i][j] = 0;
                max = Math.max(max, dp[i][j]);
            }
        }
        return max;
    }
}
```
解法二：优化空间,空间复杂度是O(max(m,n))
```
class Solution {
    public int findLength(int[] A, int[] B) {
        int len1 = A.length;
        int len2 = B.length;
        int[] dp = new int[len2 + 1];
        int max = 0;
        for(int i = 1; i <= len1; ++i){
            for(int j = len2; j > 0; --j){
                if(A[i - 1] == B[j - 1]){
                    dp[j] = dp[j - 1] + 1;
                    max = Math.max(max, dp[j]);    
                }
                else
                    dp[j] = 0;
            }
        }
        return max;            
    }
}
```